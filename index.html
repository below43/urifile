<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>URL File - share files embedded within URLs</title>
	<link rel="stylesheet" href="style.css">
	<link rel="manifest" href="manifest.json">
	<link rel="icon" href="icon.png" type="image/png">
</head>

<body>
	<div id="loading"></div>
	<div class="container">
		<h1>URL File</h1>
		<p class="introtext">Share URLs containing Base64-encoded files.<br />Fully client-side. Your files are not stored on any server.</p>
		<div id="create-payload">
			<input type="file" id="fileInput" onchange="convertFile()">
			<p><em>Note: this works best with small files</em></p>
		</div>
		<div id="payload-error" class="note">
			<b>Error: Unable to load file</b><br /><br />
			This normally occurs with larger files, when the browser truncates the query string. You may want to paste the URL + payload instead.<br /><br />
			<button onclick="pastePayload(event)" class="button-solid">Paste the URL + Payload</button>
		</div>
		<div id="display-payload">
			<div class="file-info">
				<p><b>Filename</b><span id="filename"></span></p>
				<p><b>File size</b><span id="fileSize"></span></p>
				<p><b>MIME type</b><span id="fileMimeType"></span></p>
				<p><b>Date &amp; time</b><span id="uploadDate"></span></p>
				<div id="filePreview"></div>
				<p id="fileContent"></p>
			</div>
			<div class="link-preview">
				<button onclick="share()" id="share" class="button-solid">Copy URL + Payload</button>
				<!-- <br /><br />
				<a href="#" onclick="copyPayload(event)" class="small-link">Copy payload</a> -->
			</div>
			</p>
			<p id="size-warning" class="note">
				<b>Warning:</b> The file is large, so some browsers may end up truncating the query string. You may need to paste the URL + payload at the other end to retrieve the file.
			</p>

		</div>
		<div id="toast"></div>
		<footer>
			<div class="footer-links">
				<a href="#" onclick="reset(event)" class="small-link">Share a file</a>
				<a href="#" onclick="pastePayload(event)" class="small-link">Paste URL + Payload</a>
				<a href="#about" onclick="showModal(event, 'about')" class="small-link">About</a>
				<a href="#terms" onclick="showModal(event, 'terms')">Terms & privacy</a>
			</div>
			<p style="margin-top: 20px; font-size: 12px;">made by <a href="https://andrew.drake.nz" style="color: #666;">andrew.drake.nz</a></p>
		</footer>
	</div>

	<script>
		const createPayloadContainer = document.getElementById('create-payload');
		const displayPayloadContainer = document.getElementById('display-payload');
		const payloadError = document.getElementById('payload-error');
		const filePreviewElement = document.getElementById('filePreview');
		const fileContentElement = document.getElementById('fileContent');
		const sizeWarning = document.getElementById('size-warning');
		const fileInput = document.getElementById('fileInput');
		const loading = document.getElementById('loading');

		//see if there's a payload in the URL
		loadPayloadFromUrl();

		function convertFile()
		{
			loading.style.display = 'block';
			sizeWarning.style.display = 'none';
			const fileInput = document.getElementById('fileInput');
			const buttonConvertFile = document.getElementById('button-convert-file');
			const file = fileInput.files[0];
			if (file)
			{
				const reader = new FileReader();

				reader.onload = function (event)
				{
					try
					{
						const base64String = event.target.result.split(',')[1];
						const params = {
							filename: file.name,
							filesize: file.size,
							mimetype: file.type,
							uploaddate: getLocalIsoTimestamp(),
							data: base64String
						};

						this.payload = encodePayload(params);

						setPayload(this.payload);
					}
					catch (e)
					{
						console.error('Failed to convert file:', e);
						alert('Failed to convert file. Please try again.');
					}
					finally
					{
						loading.style.display = 'none';
					}
				};
				reader.readAsDataURL(file);
			} else
			{
				alert('Please select a file first.');
			}
		}

		function encodePayload(params)
		{
			return btoa(JSON.stringify({
				filename: params.filename,
				filesize: params.filesize,
				mimetype: params.mimetype,
				uploaddate: params.uploaddate,
				data: params.data
			}));
		}

		function decodePayload(encodedPayload)
		{
			try
			{
				return JSON.parse(atob(encodedPayload));
			}
			catch (e)
			{
				console.error('Failed to decode payload:', e);
				return null;
			}
		}

		function share()
		{
			this.copyToClipboard('URL');
		}

		function copyPayload(event)
		{
			if (event)
			{
				event.preventDefault();
			}
			this.copyToClipboard('Payload');
			return;
		}

		function copyToClipboard(type)
		{
			let text = '';
			if (type === 'URL')
			{
				text = window.location.href;
			}
			else if (type === 'Payload')
			{
				text = `${this.payload}`;
			}

			navigator.clipboard.writeText(text).then(() =>
			{
				showToast(`${type} copied!`);
			}).catch(err =>
			{
				console.error('Could not copy text: ', err);
			});
		}

		function getLocalIsoTimestamp()
		{
			const date = new Date();
			const offset = date.getTimezoneOffset();
			const sign = offset > 0 ? '-' : '+';
			const absOffset = Math.abs(offset);
			const hoursOffset = String(Math.floor(absOffset / 60)).padStart(2, '0');
			const minutesOffset = String(absOffset % 60).padStart(2, '0');
			const isoString = date.toISOString().split('.')[0];
			return `${isoString}${sign}${hoursOffset}:${minutesOffset}`;
		}

		function formatNumberWithCommas(number)
		{
			return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
		}

		function showWarning()
		{
			if (this.payload.length > 2000000)
			{
				sizeWarning.style.display = 'block';
			} else
			{
				sizeWarning.style.display = 'none';
			}
		}

		function showToast(message)
		{
			const toast = document.getElementById('toast');
			toast.textContent = message;
			toast.className = 'show';
			setTimeout(() =>
			{
				toast.className = toast.className.replace('show', '');
			}, 3000);
		}

		function reset(event, updateState = true)
		{
			if (event)
			{
				event.preventDefault();
			}
			this.payload = '';

			createPayloadContainer.style.display = 'inline';
			displayPayloadContainer.style.display = 'none';
			payloadError.style.display = 'none';
			sizeWarning.style.display = 'none';
			fileInput.value = '';
			filePreviewElement.innerHTML = '';
			fileContentElement.innerHTML = '';

			//set the url back to the base url
			if (updateState) 
			{
				history.pushState(null, '', `${window.location.origin}${window.location.pathname}`);
			}
		}

		function pastePayload(event)
		{
			if (event)
			{
				event.preventDefault();
			}
			//prompt for payload
			let pastedPayload = prompt("Paste a URL+payload that was generated from this app");

			if (pastedPayload)
			{
				try
				{
					if (pastedPayload.includes('#')) 
					{
						pastedPayload = pastedPayload.substring(pastedPayload.indexOf('#') + 1);
					}
					this.payload = pastedPayload;
					var params = getQueryParamsFromPayload(pastedPayload);
					if (!params)
					{
						displayPayloadContainer.style.display = 'none';
						alert('Sorry, unable to parse that URL + Payload');
						return;
					}
					displayFileDetails(params);
				}
				catch (e)
				{
					console.error(e);
				}
			}
		}

		function showFileDetailsContainer()
		{
			// Update the display with the file information
			createPayloadContainer.style.display = 'none';
			displayPayloadContainer.style.display = 'inline';
			payloadError.style.display = 'none';
		}

		function setPayload(payload)
		{
			this.payload = payload;

			// Revert cursor back to default
			document.body.style.cursor = 'default';

			this.showWarning();

			// Update the URL in the browser address bar
			history.pushState(null, '', `${window.location.origin}${window.location.pathname}#${payload}`);

			var params = getQueryParamsFromPayload(payload);
			displayFileDetails(params);
		}

		let params = '';
		function displayFileDetails(params)
		{
			this.params = '';
			this.showFileDetailsContainer();

			const filenameElement = document.getElementById('filename');
			const fileSizeElement = document.getElementById('fileSize');
			const fileMimeTypeElement = document.getElementById('fileMimeType');
			const uploadDateElement = document.getElementById('uploadDate');
			if (params.base64String)
			{
				fileContentElement.innerHTML = '';
				this.params = params;

				document.title = `URL File Share - ${params.filename}`; // Update the page title with the filename
				filenameElement.textContent = params.filename;
				fileSizeElement.textContent = formatFileSize(params.filesize);
				fileMimeTypeElement.textContent = params.mimeType;
				uploadDateElement.textContent = params.uploadDate;

				const blob = base64ToBlob(params.base64String, params.mimeType);
				const url = URL.createObjectURL(blob);

				// Check if the file is an image
				if (params.filename.match(/\.(jpeg|jpg|gif|png)$/))
				{
					const imgLink = document.createElement('a');
					imgLink.href = url;
					imgLink.target = '_blank';

					const img = document.createElement('img');
					img.src = url;
					img.alt = params.filename;
					img.style.maxWidth = '200px';
					img.style.maxHeight = '200px';
					img.style.border = '1px solid #ccc';
					img.style.marginBottom = '10px';

					imgLink.appendChild(img);
					filePreviewElement.appendChild(imgLink);
				}

				const link = document.createElement('a');
				link.href = url;
				link.download = params.filename;
				link.innerHTML = 'â¬‡ &nbsp;Download this file';
				link.className = 'button button-outline download-button';
				fileContentElement.appendChild(link);
			} else
			{
				fileContentElement.textContent = 'No data found.';
			}
		}

		function loadPayloadFromUrl()
		{
			if (!window?.location?.hash)
			{
				this.reset(null, false);
				return;
			}
			else
			{
				try
				{
					const payload = window.location.hash.substring(1);
					if (!payload)
					{
						this.reset(null, false);
						return;
					}

					if (payload == 'privacy')
					{
						showModal(null, 'privacy');
						return;
					}
					else if (payload == 'terms')
					{
						showModal(null, 'terms');
						return;
					}

					this.payload = payload;
					this.showFileDetailsContainer();
					var params = this.getQueryParamsFromPayload(payload);
					if (!params)
					{
						displayPayloadContainer.style.display = 'none';
						payloadError.style.display = 'block';
						return;
					}
					this.displayFileDetails(params);

					this.showWarning();
				}
				catch (e)
				{
					console.error(e);
				}
			}
		}

		function getQueryParamsFromPayload(payload)
		{
			try
			{
				const params = decodePayload(payload);
				return {
					base64String: params.data,
					filename: params.filename || 'downloaded_file',
					filesize: params.filesize || 'Unknown size',
					mimeType: params.mimetype || 'application/octet-stream',
					uploadDate: params.uploaddate || 'Unknown date'
				};
			} catch (e)
			{
				console.error(e);
				return null;
			}
		}

		function base64ToBlob(base64, mime)
		{
			const byteCharacters = atob(base64);
			const byteNumbers = new Array(byteCharacters.length);
			for (let i = 0; i < byteCharacters.length; i++)
			{
				byteNumbers[i] = byteCharacters.charCodeAt(i);
			}
			const byteArray = new Uint8Array(byteNumbers);
			return new Blob([byteArray], { type: mime });
		}

		function formatFileSize(bytes)
		{
			if (bytes === 0) return '0 Bytes';
			const k = 1024;
			const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
			const i = Math.floor(Math.log(bytes) / Math.log(k));
			const formattedSize = (bytes / Math.pow(k, i)).toFixed(2) + ' ' + sizes[i];
			return formattedSize.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
		}

		function showModal(event, modalId)
		{
			if (event)
			{
				event.preventDefault();
			}
			document.getElementById(modalId).style.display = 'block';
		}

		function closeModal(modalId)
		{
			document.getElementById(modalId).style.display = 'none';
		}

		function handleModalClick(event, modalId)
		{
			// If clicking the backdrop (not the modal content), close the modal
			if (event.target.classList.contains('modal'))
			{
				closeModal(modalId);
			}
		}

		if ('serviceWorker' in navigator)
		{
			navigator.serviceWorker.register('/service-worker.js')
				.then(registration =>
				{
					console.log('ServiceWorker registration successful with scope: ', registration.scope);
				})
				.catch(error =>
				{
					console.log('ServiceWorker registration failed: ', error);
				});
		}
	</script>

	<div id="terms" class="modal" onclick="handleModalClick(event, 'terms')">
		<div class="modal-content">
			<h3>Terms of Service</h3>
			<div class="modal-body">
				<p>This service is provided "as is" without any warranties, express or implied. Use of this service is at your own risk. The service provider does not guarantee the availability, accuracy, or functionality of the service.</p>
				<p>Users must not use this service for any illegal or unauthorized purposes.</p>
			</div>
			<h3>Privacy Policy</h3>
			<div class="modal-body">
				<p>We respect your privacy. None of your data is stored or tracked. No files are saved on a server. Cloudflare Web Analytics record privacy-first anonymous usage data.</p>
			</div>
			<div class="modal-buttons">
				<button onclick="closeModal('terms')" class="button-outline">Close</button>
			</div>
		</div>
	</div>

	<div id="about" class="modal" onclick="handleModalClick(event, 'about')">
		<div class="modal-content">
			<h2>About</h2>
			<div class="modal-body">
				<p>I use multiple machines with a shared keyboard and mouse (I use <a href="https://github.com/input-leap/input-leap" nofollow="nofollow" target="_blank">InputLeap</a>). I created this tool so that I could easily transfer files from one machine to another using a shared clipboard. This works equally well pasting into a chat or an email, but may meet varying degrees of success depending on the transport mechanism.</p>
				<p>To an extent, this is an academic exercise: to show that a file can be transported via a URL. However, I do find it jolly useful for small file transfers. Coupled with Edge's QR code generator, it's fairly handy for getting a small file onto a mobile.</p>
				<p>Because the payload is transported via the # fragment, theoretically the payload is only loaded local to the client, and not sent to the server.</p>
				<p>Suffice to say, this is completely useless for larger files, though it's fun to see what each brower's limit is...</p>
				<p>Made with a bit of help from GitHub Copilot</p>
				<p>&copy; <a href="https://andrew.drake.nz" style="text-decoration: none;">Andrew Drake</a>  2025</p>
			</div>
			<div class="modal-buttons">
				<button onclick="closeModal('about')" class="button-outline">Close</button>
			</div>
		</div>
	</div>
</body>

</html>